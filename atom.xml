<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AnCIity.github.io</id>
    <title>AnBlog</title>
    <updated>2020-03-20T13:22:36.893Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AnCIity.github.io"/>
    <link rel="self" href="https://AnCIity.github.io/atom.xml"/>
    <subtitle>学以致用。</subtitle>
    <logo>https://AnCIity.github.io/images/avatar.png</logo>
    <icon>https://AnCIity.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, AnBlog</rights>
    <entry>
        <title type="html"><![CDATA[Webpack - 前端工程化]]></title>
        <id>https://AnCIity.github.io/post/webpack-project/</id>
        <link href="https://AnCIity.github.io/post/webpack-project/">
        </link>
        <updated>2020-03-19T10:46:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="webpack-前端工程化">Webpack-前端工程化</h1>
<hr>
<blockquote>
<p><code>Organized by</code>：<strong>安南</strong> <code>City</code></p>
<p><code>Completion time</code>：<code>2020-03-19</code></p>
<p><code>Send error to email</code>：<a href="mailto:city@nanzc.com" title="send to email">city@nanzc.com</a></p>
</blockquote>
<hr>
<blockquote>
<p><code>Webpack</code>：<code>让一切变得简单</code></p>
<blockquote>
<p>是一个流行的前端项目构建工具（打包工具）。</p>
</blockquote>
<p><code>作用</code>：</p>
<blockquote>
<p>可以解决当前 Web 开发中所面临的困境。</p>
</blockquote>
<p><code>webpack</code>提供了友好的模块化支持，以及代码压缩混淆、处理<code>js</code>兼容问题、性能优化等强大的功能，从而让程序员 <strong>把工作的重心放到具体的功能实现上，提高了开发效率和项目的可维护性</strong>。</p>
</blockquote>
<p> </p>
<p>当前 Web 开发面临的困境</p>
<hr>
<blockquote>
<ul>
<li>文件依赖关系错综复杂</li>
<li>静态资源请求效率低</li>
<li>模块化支持不友好</li>
<li>浏览器对高级Javascript 特性兼容程度较低</li>
<li>etc…</li>
</ul>
</blockquote>
<p> </p>
<h2 id="webpack-项目">Webpack 项目</h2>
<hr>
<blockquote>
<p>那么了解了<code>Webpack</code>因何而存在，接下来就开始创建<code>Webpack</code>项目吧。</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>新建项目空白目录</p>
</li>
<li>
<p>运行命令，初始化包管理配置文件<code>package.json</code></p>
<pre><code class="language-shell">npm init –y
</code></pre>
</li>
<li>
<p>新建<code>src</code>源代码目录</p>
</li>
<li>
<p>新建<code>src =&gt; index.html</code>：首页</p>
</li>
<li>
<p>初始化首页基本结构</p>
</li>
<li>
<p>创建入口文件<code>src =&gt; index.js</code></p>
</li>
</ul>
<p> </p>
<h2 id="安装和配置">安装和配置</h2>
<hr>
<blockquote>
<p>接下来让我们在项目中开始安装<code>webpack</code></p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装<code>webpack</code>相关的包</p>
<pre><code class="language-shell">npm install webpack webpack-cli –D
</code></pre>
</li>
<li>
<p>在项目根目录中创建<code>webpack</code>配置文件：<code>webpack.config.js</code></p>
<pre><code class="language-js">// webpack.config.js

module.exports = {
    // 指定构建模式
    // value：development-不会压缩不会混淆; production-压缩并混淆
    mode: &quot;development&quot;
}
</code></pre>
</li>
<li>
<p>在<code>package.json</code>配置文件中的<code>scripts</code>节点下，新增 dev 脚本如下：</p>
<pre><code class="language-javascript">// script 节点下的脚本，可以通过 npm run key 执行
&quot;scripts&quot;: {
	&quot;dev&quot;: &quot;webpack&quot;
}
</code></pre>
</li>
<li>
<p>打包<code>Webpack</code></p>
<pre><code class="language-shell">npm run dev
</code></pre>
</li>
</ul>
<p> </p>
<h3 id="入口和出口">入口和出口</h3>
<hr>
<blockquote>
<p>打包的默认约定：</p>
<p><strong>入口文件</strong>：<code>src</code> =&gt; <code>index.js</code></p>
<p><strong>出口文件</strong>：<code>dist</code> =&gt; <code>main.js</code></p>
</blockquote>
<p> </p>
<blockquote>
<p>接下来，我们看下如何修改打包的入口和出口：</p>
</blockquote>
<pre><code class="language-javascript">// webpack.config.js

const path = require(&quot;path&quot;); // 引入路径处理模块

module.exports = {
    // ...
    // 入口文件路径
    entry: path.join(__dirname, &quot;./src/index.js&quot;),
    // 出口
    output: {
        // 路径
        path: path.join(__dirname, &quot;./dist&quot;),
        // 文件名
        filename: &quot;bundle.js&quot;
    }
};
</code></pre>
<p> </p>
<h3 id="自动打包">自动打包</h3>
<hr>
<blockquote>
<p>在修改完项目后，总是需要重新打包，那么如何自动打包呢？</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装支持项目自动打包的工具</p>
<pre><code class="language-shell">npm install webpack-dev-server –D
</code></pre>
</li>
<li>
<p>修改<code>package.json =&gt; scripts</code>中的<code>dev</code>命令</p>
<pre><code class="language-javascript">&quot;scripts&quot;: {
	&quot;dev&quot;: &quot;webpack-dev-server&quot;
}
</code></pre>
</li>
<li>
<p><mark>注意</mark>：打包后的文件在<code>webpack-dev-server</code>启动的http服务器<code>/</code>根目录下，且打包的文件处于内存中，项目下不可见</p>
<pre><code class="language-html">&lt;!-- 如打包文件名：buldle.js --&gt;
&lt;!-- 引用时使用 --&gt;
&lt;script src=&quot;/buldle.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>
<p>运行命令即可启动自动打包服务器</p>
<pre><code class="language-shell">npm run dev
</code></pre>
</li>
<li>
<p>打开服务器默认地址查看：<code>http://localhost:8080</code></p>
</li>
</ul>
<p> </p>
<blockquote>
<p>每次都需要手动打开服务器？看完下面的<code>相关配置</code>小结，你的疑惑便可以解决。</p>
</blockquote>
<p> </p>
<h5 id="相关配置">相关配置</h5>
<hr>
<blockquote>
<p>配置自动打包相关的参数，<code>package.json =&gt; scripts =&gt; dev</code></p>
</blockquote>
<pre><code class="language-javascript"> // package.json

 // --open 打包完成后自动打开浏览器页面
 // --host 配置 IP 地址
 // --port 配置端口
 &quot;scripts&quot;: { 
    &quot;dev&quot;: &quot;webpack-dev-server --open --host 127.0.0.1 --port 8888&quot; 
  }
</code></pre>
<p> </p>
<blockquote>
<p>虽然可以自动打开浏览器页面了，但是打开的页面却不对。</p>
<p>这是因为服务器<code>/</code>和项目根目录一致，而预览页面处于<code>src</code>下，那么我们该如何解决？</p>
</blockquote>
<p> </p>
<h3 id="生成预览页面">生成预览页面</h3>
<hr>
<blockquote>
<p>接下来我们使用插件<code>html-webpack-plugin</code>配置项目预览页面</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装生成预览页面的插件</p>
<pre><code class="language-shell">npm install html-webpack-plugin –D
</code></pre>
</li>
<li>
<p>修改<code>webpack.config.js</code>文件头部区域</p>
<pre><code class="language-javascript">// webpack.config.js

// 导入生成预览页面插件
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

// 创建插件实例对象
const htmlPlugin = new HtmlWebpackPlugin({
    // 指定模板文件
    template: &quot;./src/index.html&quot;,
    // 指定生成文件名，文件处于内存中，在目录不显示
    filename: &quot;index.html&quot;
});

// ...
</code></pre>
</li>
<li>
<p>修改<code>webpack.config.js</code>文件中向外暴露的配置对象，新增如下配置节点：</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
    plugins: [ htmlPlugin] // plugins 数组是webpack 打包期间会用到的一些插件列表
}
</code></pre>
</li>
<li>
<p>启动打包服务器查看即可</p>
</li>
</ul>
<p> </p>
<h2 id="加载器">加载器</h2>
<hr>
<blockquote>
<p>在实际开发过程中，<code>webpack</code>默认只能打包处理以<code>.js</code>后缀名结尾的模块。其他非<code>.js</code>后缀名结尾的模块，webpack 默认处理不了。需要调用 <code>loader</code> 加载器才可以正常打包，否则会报错！</p>
<p><code>loader</code>加载器可以协助 <code>webpack</code> 打包处理特定的文件模块，比如：</p>
<ul>
<li><code>less-loader</code> 可以打包处理 <code>.less</code> 相关的文件</li>
<li><code>sass-loader</code> 可以打包处理 <code>.scss</code> 相关的文件</li>
<li><code>url-loader</code> 可以打包处理 <code>css</code> 中与 <code>url 路径</code>相关的文件</li>
</ul>
<p>项目选择<code>loader</code>时：<strong>按需选择</strong></p>
</blockquote>
<p> </p>
<h3 id="打包处理-css-文件">打包处理 CSS 文件</h3>
<hr>
<blockquote>
<p>处理<code>.CSS</code>文件</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装处理<code>.css</code>文件的<code>loader</code></p>
<pre><code class="language-shell">npm i style-loader css-loader -D
</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，添加<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { test: /\.css$/, use: ['style-loader', 'css-loader'] }
         ]
     }
}
</code></pre>
<p><mark>注意</mark>：</p>
<ul>
<li><code>use</code> 数组中指定的 <code>loader</code> <strong>顺序是固定的</strong></li>
<li>多个 <code>loader</code> 的调用顺序是：<strong>从后往前调用</strong></li>
</ul>
</li>
</ul>
<p> </p>
<h3 id="打包处理-less-文件">打包处理 LESS 文件</h3>
<hr>
<blockquote>
<p>处理<code>.less</code>文件</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装处理<code>.less</code>文件的<code>loader</code></p>
<pre><code class="language-shell">npm i less-loader less -D

</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，添加<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }
         ]
     }
}

</code></pre>
</li>
</ul>
<p> </p>
<h3 id="打包处理-scss-文件">打包处理 SCSS 文件</h3>
<hr>
<blockquote>
<p>处理<code>.scss</code>文件</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装处理<code>.scss</code>文件的<code>loader</code></p>
<pre><code class="language-shell">npm i sass-loader node-sass -D

</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，添加<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }
         ]
     }
}

</code></pre>
</li>
</ul>
<p> </p>
<h3 id="处理-css-兼容前缀">处理 CSS 兼容前缀</h3>
<hr>
<blockquote>
<p>处理<code>css</code>的兼容性问题，通过自动添加兼容后缀的方式</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装<code>postcss-loader</code>加载器和<code>autoprefixer</code>自动添加前缀插件</p>
<pre><code class="language-shell">npm i postcss-loader autoprefixer -D

</code></pre>
</li>
<li>
<p>在项目根目录创建<code>postCSS</code>的配置文件：<code>postcss.config.js</code></p>
<pre><code class="language-javascript">// postcss.config.js

const autoprefixer = require('autoprefixer') // 导入自动添加前缀的插件
    module.exports = {
    	plugins: [ autoprefixer ] // 挂载插件
    }
}

</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，修改<code>css</code>的<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] }
         ]
     }
}

</code></pre>
</li>
</ul>
<p> </p>
<h3 id="处理样式表中图片和字体文件">处理样式表中图片和字体文件</h3>
<hr>
<blockquote>
<p>打包样式表中的<code>图片</code>和<code>字体文件</code></p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装处理路径和文件的<code>loader</code></p>
<pre><code class="language-shell">npm i url-loader file-loader -D

</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，添加<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { 
                 test: /\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, 
                 use: 'url-loader?limit=16940' // ?limit=16940 参数项可不写
             }
         ]
     }
}

</code></pre>
<p><code>limit</code>:用来指定图片的大小，单位是字节(byte)，只有小于<code>limit</code>大小的图片，才会被转为<code>base64</code>图片</p>
</li>
</ul>
<p> </p>
<h3 id="处理-js-高级语法">处理 JS 高级语法</h3>
<hr>
<blockquote>
<p>ES5后的语法支持并不是很好，所以我们可以通过<code>babel</code>插件去处理<code>.js</code>文件，转换语法</p>
</blockquote>
<p> </p>
<ul>
<li>
<p>安装<code>babel</code>转换器相关的包</p>
<pre><code class="language-shell">npm i babel-loader @babel/core @babel/runtime -D

</code></pre>
</li>
<li>
<p>安装<code>babel</code>语法插件相关的包</p>
<pre><code class="language-shell">npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties –D

</code></pre>
</li>
<li>
<p>在根目录中创建<code>babel</code>配置文件<code>babel.config.js</code></p>
<pre><code class="language-javascript">// babel.config.js

module.exports = {
     presets: [ '@babel/preset-env' ],
     plugins: [ '@babel/plugin-transform-runtime', '@babel/plugin-proposal-class-properties' ]
 }

</code></pre>
</li>
<li>
<p>在<code>webpack.config.js</code>的<code>module =&gt; rules</code>中，修改<code>css</code>的<code>loader</code>规则</p>
<pre><code class="language-javascript">// webpack.config.js

// ...
module.exports = {
    // ...
     module: { // 所有第三方文件模块的匹配规则 
         rules: [ // 多个规则逗号分割
             // test：匹配的文件类型; use：表示对应要调用的 loader
             { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }
             // exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件
         ]
     }
}

</code></pre>
</li>
</ul>
<p> </p>
<p> </p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6 - 模块化]]></title>
        <id>https://AnCIity.github.io/post/es6-module/</id>
        <link href="https://AnCIity.github.io/post/es6-module/">
        </link>
        <updated>2020-03-16T13:13:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="es6模块化">ES6模块化</h1>
<hr>
<blockquote>
<p><code>Organized by</code>：<strong>安南</strong> <code>City</code></p>
<p><code>Completion time</code>：<code>2020-03-16</code></p>
<p><code>Send error to email</code>：<a href="mailto:city@nanzc.com" title="send error to email">city@nanzc.com</a></p>
</blockquote>
<hr>
<blockquote>
<p>在<code>ES6</code>模块化规范诞生之前，Javascript 社区已经尝试并提出了<code>AMD</code>、<code>CMD</code>、<code>CommonJS</code> 等模块化规范。</p>
<p>但是，这些社区提出的模块化标准，还是存在一定的<strong>差异性</strong>与<strong>局限性</strong>、<strong>并不是</strong>浏览器与服务器<strong>通用的模块化标</strong></p>
<p><strong>准</strong>，例如：</p>
<ul>
<li><code>AMD</code>和<code>CMD</code>适用于浏览器端的<code>Javascript</code>模块化</li>
<li><code>CommonJS</code>适用于服务器端的<code>Javascript</code>模块化</li>
</ul>
<p>因此，<code>ES6</code>语法规范中，在语言层面上定义了<code>ES6</code>模块化规范，是浏览器端与服务器端通用的模块化开发规范。</p>
<p><code>定义</code>：</p>
<ul>
<li>每个 js 文件都是一个独立的模块</li>
<li><strong>导入模块成员</strong>使用<code>import</code>关键字</li>
<li><strong>暴露模块成员</strong>使用<code>export</code>关键字</li>
</ul>
</blockquote>
<h3 id="在nodejs中使用babel体验es6模块化">在Node.js中使用babel体验ES6模块化</h3>
<hr>
<blockquote>
<p>由于<code>Node.js</code>并不支持<code>ES6</code>模块化相关操作，我们需要通过<code>babel</code>进行语法转换。</p>
</blockquote>
<ul>
<li>
<p>安装相关开发环境</p>
<pre><code class="language-shell">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
</code></pre>
</li>
<li>
<p>安装项目相关依赖</p>
<pre><code class="language-shell">npm install --save @babel/polyfill
</code></pre>
</li>
<li>
<p>在项目根目录创建文件：<code>babel.config.js</code></p>
<pre><code class="language-javascript">const presets = [
    [&quot;@babel/env&quot;, {
        targets: {
            edge: &quot;17&quot;,
            firefox: &quot;60&quot;,
            chrome: &quot;67&quot;,
            safari: &quot;11.1&quot;
        }
    }]
]
module.exports = { presets }
</code></pre>
</li>
<li>
<p>运行文件</p>
<pre><code class="language-shell">npx babel-node 文件名
</code></pre>
</li>
</ul>
<p> </p>
<h3 id="默认导入导出">默认导入导出</h3>
<hr>
<blockquote>
<p>默认导出只能使用一次</p>
<p><code>export default { value }</code></p>
</blockquote>
<pre><code class="language-javascript">// m1.js
let defaultA = &quot;defaultA&quot;
let defaultB = function(){
    console.log(&quot;defaultB&quot;)
}

export default {
    defaultA,
    defaultB
}

// m2.js
import defaultAll from './m1'
</code></pre>
<p> </p>
<h3 id="按需导入导出">按需导入导出</h3>
<hr>
<blockquote>
<p>按需导出可以使用多次</p>
<p><code>export value</code></p>
</blockquote>
<pre><code class="language-javascript">// m1.js
export let needA = &quot;needA&quot;

export let needB = &quot;needB&quot;

export let needC = function(){
    console.log(&quot;needC&quot;)
}

// m2.js
import { needA, needC } form &quot;./m1&quot;
</code></pre>
<p> </p>
<h3 id="默认和按需结合使用时">默认和按需结合使用时</h3>
<hr>
<blockquote>
<p>在我们同时使用默认导出和按需导出时，导入时使用逗号分割即可。</p>
</blockquote>
<pre><code class="language-javascript">// m1.js
let defaultA = &quot;defaultA&quot;
let defaultB = function(){
    console.log(&quot;defaultB&quot;)
}
// 默认导出
export default {
    defaultA,
    defaultB
}

// 按需导出
export let needA = &quot;needA&quot;
export let needB = &quot;needB&quot;
export let needC = function(){
    console.log(&quot;needC&quot;)
}

// m2.js
import defaultAll, { needA, needC } from './m1'
</code></pre>
<p> </p>
<h3 id="导入重命名">导入重命名</h3>
<hr>
<blockquote>
<p>在导入模块时，会遇见模块变量重名的情况，那么怎么解决它呢？</p>
<p>这个时候可以用到我们的<code>as</code>关键字</p>
</blockquote>
<pre><code class="language-javascript">// m1.js
export let needA = &quot;needA&quot;

export let needB = &quot;needB&quot;

export let needC = function(){
    console.log(&quot;needC&quot;)
}

// m2.js
import { needA as needRename, needC } form &quot;./m1&quot;
// 例如此时模块内已存在needA变量，所以可以使用as重命名导入变量名为needRename。
let needA = &quot;已存在变量needA&quot;
</code></pre>
<p> </p>
<h3 id="导入一个空模块时">导入一个空模块时</h3>
<hr>
<blockquote>
<p>我们无需担心导入一个未暴露任何变量的模块时会出错。</p>
<p>因为当导入一个空模块时，系统默认返回一个空对象<code>{}</code></p>
</blockquote>
<p> </p>
<h3 id="直接导入并执行模块代码">直接导入并执行模块代码</h3>
<hr>
<blockquote>
<p>在我们只想执行模块内的代码，却不想导入模块内的变量时</p>
</blockquote>
<pre><code class="language-javascript">// m1.js
for (let i = 0; i &lt; 3; i++) {
    console.log(i);
}

// m2.js
import './m2'
// 导入的模块内部代码会自动执行
</code></pre>
<p> </p>
<p> </p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node操作原生mongodb模块]]></title>
        <id>https://AnCIity.github.io/post/node-mongodb/</id>
        <link href="https://AnCIity.github.io/post/node-mongodb/">
        </link>
        <updated>2020-03-14T13:21:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="node操作原生mongodb模块">Node操作原生mongodb模块</h1>
<hr>
<blockquote>
<p><code>Organized by</code>：<strong>安南</strong> <code>City</code></p>
<p><code>Completion time</code>：<code>2020-03-14</code></p>
<p><code>Send error to email</code>：<a href="mailto:city@nanzc.com" title="send to email">city@nanzc.com</a></p>
</blockquote>
<hr>
<blockquote>
<p><code>MongoDB</code> 是一个<strong>基于分布式文件存储</strong>的数据库。由 C++ 语言编写。旨在为 WEB 应用<strong>提供可扩展的高性能数据存储解决方案</strong>。</p>
<p><code>MongoDB</code> 是一个<strong>介于关系数据库和非关系数据库之间</strong>的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p><code>Node</code>原生的<code>MongoDB</code>驱动：<code>mongodb</code>模块</p>
</blockquote>
<p> </p>
<h3 id="安装驱动">安装驱动</h3>
<hr>
<blockquote>
<p>在当前项目安装<code>mongodb</code>驱动模块</p>
</blockquote>
<pre><code class="language-shell">npm install mongodb
</code></pre>
<p> </p>
<h3 id="连接数据库">连接数据库</h3>
<hr>
<blockquote>
<p>首先创建一个<code>MongoClient</code>对象，然后配置好<code>地址</code>和<code>端口</code>以及<code>数据库</code> ，默认端口可省略。</p>
<p>如果数据库不存在，<code>MongoDB</code>将创建数据库并建立连接。</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;
// mongodb://host:port/db
MongoClient.connect('mongodb://localhost:27017/stu', { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err; // 如果发生错误，抛出错误
    console.log(&quot;连接成功&quot;);
    // 关闭数据库
    db.close();
})
</code></pre>
<p> </p>
<h3 id="创建集合">创建集合</h3>
<hr>
<blockquote>
<p><code>createCollection()</code>：创建一个集合。</p>
<p>在未创建集合的情况下使用集合，集合将会自动创建。</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

// 如果数据库不存在，将会隐式创建
MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err; // 如果发生错误，抛出错误

    // 选择数据库 blog
    let dbase = db.db(&quot;blog&quot;);

    // 主动创建集合
    dbase.createCollection(&quot;filing&quot;, (err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;创建集合&quot;);
        
        // 关闭数据库
        db.close();
    })
})
</code></pre>
<p> </p>
<h3 id="删除集合">删除集合</h3>
<hr>
<blockquote>
<p><code>collection()</code>：选择集合。</p>
<p><code>drop</code>：删除集合。</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;

    // 选择数据库 blog
    let dbase = db.db(&quot;blog&quot;);

    // collection()选择集合，drop()删除集合
    dbase.collection(&quot;filing&quot;).drop((err, delOK) =&gt; {
        if (err) throw err;

        if (delOK) console.log(&quot;集合已删除&quot;);

        db.close();
    })
})
</code></pre>
<p> </p>
<h2 id="数据库操作-curd">数据库操作( CURD )</h2>
<hr>
<blockquote>
<p>接下来我们将学习数据库的增删改查操作。</p>
<p>与<code>MySQL</code>不同的是**<code>MongoDB</code>会自动创建数据库和集合**，所以使用前我们不需要手动去创建。</p>
</blockquote>
<p> </p>
<h3 id="插入文档">插入文档</h3>
<hr>
<blockquote>
<p><code>insertOne({insert data}, callback)</code>：插入一条数据</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
	let dbase = db.db(&quot;blog&quot;);

    let insertData = { name: &quot;南之城&quot;, url: &quot;nanzc.com&quot;, rank: &quot;1&quot; };
    dbase.collection(&quot;filing&quot;).insertOne(insertData, (err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;插入文档成功&quot;);

        db.close();
    })
})
</code></pre>
<blockquote>
<p><code>insertOne([{insert data},...], callback)</code>：插入多条数据</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    let insData = [
        { name: &quot;南之城&quot;, url: &quot;nanzc.com&quot;, rank: &quot;3&quot; },
        { name: &quot;百度&quot;, url: &quot;baidu.com&quot;, rank: &quot;5&quot; },
        { name: &quot;南之城&quot;, url: &quot;nanzc.com&quot;, rank: &quot;1&quot; },
        { name: &quot;谷歌&quot;, url: &quot;google.com&quot;, rank: &quot;4&quot; },
        { name: &quot;谷歌&quot;, url: &quot;google.com&quot;, rank: &quot;2&quot; }
    ];
    dbase.collection(&quot;filing&quot;).insertMany(insData, (err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;插入的文档数量为: &quot;, res.insertedCount);

        db.close();
    })
})
</code></pre>
<p> </p>
<h3 id="查询文档">查询文档</h3>
<hr>
<blockquote>
<p><code>find({ })</code>：查询文档，返回匹配条件的所有文档</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    // 查询所有文档，不指定条件即可
    dbase.collection(&quot;filing&quot;).find({}).toArray((err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;查询所有文档：&quot;, res);
        
        // db.close();
    })

    // 查询指定条件文档
    dbase.collection(&quot;filing&quot;).find({ name: &quot;南之城&quot; }).toArray((err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;指定条件文档：&quot;, res);
        
        // db.close();
    })
})
</code></pre>
<p> </p>
<h3 id="更新文档">更新文档</h3>
<hr>
<blockquote>
<p><code>updateOne({ }, {$: { }}, callback)</code>：更新一条文档</p>
<p><code>updateMany({ }, {$: { }}, callback)</code>：更新符合条件的所有文档</p>
<p><code>update</code>：需要包含<code>原子操作符</code>，如<code>$set</code></p>
<p>https://www.runoob.com/mongodb/mongodb-atomic-operations.html（参考）</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    // 只会更新一条文档
    dbase.collection(&quot;filing&quot;).updateOne({ name: &quot;南之城&quot; }, { $set: { url: &quot;www.nanzc.com&quot; } }, (err, res) =&gt; {
        if (err) throw err;
        
        console.log(&quot;文档更新成功&quot;);
        
        // db.close();
    })

    // 更新符合条件的所有数据
    dbase.collection(&quot;filing&quot;).updateMany({ name: &quot;谷歌&quot; }, { $set: { url: &quot;www.google.com&quot; } }, (err, res) =&gt; {
        if (err) throw err;
        
        console.log(res.result.nModified + &quot; 条文档被更新&quot;);
        
        // db.close();
    });
})
</code></pre>
<p> </p>
<h3 id="删除文档">删除文档</h3>
<hr>
<blockquote>
<p><code>deleteOne({ }, callback)</code>：删除一条文档</p>
<p><code>deleteMany({ }, callback)</code>：删除符合条件的所有文档</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    // 删除一条文档
    dbase.collection(&quot;site&quot;).deleteOne({ name: &quot;谷歌&quot; }, (err, obj) =&gt; {
        if (err) throw err;
        
        console.log(&quot;文档删除成功&quot;);
        
        // db.close();
    });

    // 删除符合条件所有文档
    dbase.collection(&quot;site&quot;).deleteMany({ name: &quot;谷歌&quot; }, (err, obj) =&gt; {
        if (err) throw err;
        
        console.log(obj.result.n + &quot; 条文档被删除&quot;);
        
        /// db.close();
    });
})
</code></pre>
<p> </p>
<h2 id="数据库功能">数据库功能</h2>
<hr>
<blockquote>
<p>接下来介绍数据库功能性操作<code>API</code>。</p>
</blockquote>
<p> </p>
<h3 id="排序">排序</h3>
<hr>
<blockquote>
<p><code>sort({ })</code>：将数据排序</p>
<p><code>{fieldName: 1/-1}</code>：排序方式，升序<code>1</code>，降序<code>-1</code></p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    // { rank: 1 }  // 按 rank 字段升序
    // { rank: -1 } // 按 rank 字段降序
    dbase.collection(&quot;filing&quot;).find().sort({ rank: 1 }).toArray((err, result) =&gt; {
        if (err) throw err;
        
        console.log(result);

        db.close();
    })
})
</code></pre>
<p> </p>
<h3 id="查询分页">查询分页</h3>
<hr>
<blockquote>
<p><code>limit(num: Number)</code>：指定的<strong>返回</strong>条数</p>
<p><code>skip(num: Number)</code>：指定的<strong>跳过</strong>条数</p>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;

    let dbase = db.db(&quot;blog&quot;);

    // 指定的返回条数
    dbase.collection(&quot;filing&quot;).find().limit(2).toArray((err, result) =&gt; {
        if (err) throw err;

        console.log(result);
        
        // db.close();
    })

    // 返回跳过2条后的2条数据
    dbase.collection(&quot;filing&quot;).find().skip(2).limit(2).toArray((err, result) =&gt; {
        if (err) throw err;

        console.log(result);

        // db.close();
    })
})
</code></pre>
<p> </p>
<h3 id="左连接">左连接</h3>
<hr>
<blockquote>
<p><code>MongoDB</code>不是一个关系型数据库，但我们可以使用<code>$lookup</code>来实现<strong>左连接</strong>。</p>
<p>假设我们有两个集合：</p>
<p><code>orders</code>：</p>
<pre><code class="language-json">[
{ _id: 1, product_id: 154, status: 1 }
]
</code></pre>
<p><code>products</code>：</p>
<pre><code class="language-json">[
{ _id: 154, name: '笔记本电脑' },
{ _id: 155, name: '耳机' },
{ _id: 156, name: '台式电脑' }
]
</code></pre>
</blockquote>
<pre><code class="language-javascript">const MongoClient = require(&quot;mongodb&quot;).MongoClient;

MongoClient.connect(&quot;mongodb://localhost/blog&quot;, { useNewUrlParser: true, useUnifiedTopology: true }, (err, db) =&gt; {
    if (err) throw err;
    let dbase = db.db(&quot;blog&quot;);

    // 操作左集合
    dbase.collection('orders').aggregate([
        {
            $lookup:
            {
                from: 'products',            // 右集合：连接集合名
                localField: 'product_id',    // 左集合 join 字段：自身字段
                foreignField: '_id',         // 右集合 join 字段：连接字段
                as: 'orderdetails'           // 新生成字段（类型array）：生成数据字段
            }
        }
    ]).toArray(function (err, res) {
        if (err) throw err;

        console.log(JSON.stringify(res));
        // [{&quot;_id&quot;:1,&quot;product_id&quot;:154,&quot;status&quot;:1,&quot;orderdetails&quot;:[{&quot;_id&quot;:154,&quot;name&quot;:&quot;笔记本电脑&quot;}]}]

        db.close();
    });
})
</code></pre>
<p> </p>
<h2 id="推荐使用mongoose">推荐使用Mongoose</h2>
<hr>
<blockquote>
<p><code>原由</code>： 让我们面对这样的困境，<strong>编写MongoDB验证，转换和业务逻辑是非常麻烦的</strong>。</p>
<p><code>Mongoose</code>：为模型提供了一种直接的，基于scheme结构去定义你的数据模型。它内置数据验证， 查询构建，业务逻辑钩子等，开箱即用。</p>
<p><code>side</code>： http://www.mongoosejs.net/</p>
</blockquote>
<p> </p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机原理]]></title>
        <id>https://AnCIity.github.io/post/computer-theory/</id>
        <link href="https://AnCIity.github.io/post/computer-theory/">
        </link>
        <updated>2020-03-05T13:18:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机原理">计算机原理</h1>
<hr>
<blockquote>
<p><code>Organized by</code>：<strong>安南</strong> <code>City</code></p>
<p><code>Completion time</code>：<code>2020-03-05</code></p>
<p><code>Send error to email</code>：<a href="mailto:city@nanzc.com" title="send to email">city@nanzc.com</a></p>
</blockquote>
<hr>
<blockquote>
<p>是现代一种用于高速计算的电子计算机器，可以进行数值计算，又可以进行逻辑计算，还具有存储记忆功能。是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。</p>
<ul>
<li>**程序自动化：**可将预先编译好的程序组纳入计算机内存，在程序的控制之下，计算机可以连续、自动地工作，不需要人为的干预。</li>
<li>**高速：**当今计算机的运算速度已经达到每秒万亿次，普通电脑也能达到每秒亿次以上，使大量复杂的科学计算问题能够得以解决。</li>
</ul>
<blockquote>
<p><strong>展现形式</strong>：硬件 =&gt; 系统软件 == 操作系统 =&gt; [ 程序设计语言 ] =&gt; 应用软件 =&gt; 用户</p>
</blockquote>
</blockquote>
<p> </p>
<h2 id="层次结构">层次结构</h2>
<hr>
<blockquote>
<p>计算机系统层次结构，指的是计算机系统由硬件和软件两大部分所构成，而如果按功能再细分，可分为7层。把计算机系统按功能分为多级层次结构，就是有利于正确理解计算机系统的工作过程，明确软件，硬件在计算机系统中的地位和作用。</p>
</blockquote>
<blockquote>
<p><code>应用软件</code>：</p>
<p><strong>应用语言级</strong>（应用程序）：</p>
<p>这一级 是为了使计算机满足某种用途而专门设计的，因此这一级语言就是各种面向问题的应用语言。</p>
<blockquote>
<p><code>系统软件</code>：</p>
<p><strong>高级语言级</strong>（高级语言）：</p>
<p>这级的机器语言就是各种高级语言， 通常用编译程序来完成高级语言翻译的工作。</p>
<blockquote>
<p><strong>汇编语言级</strong>（汇编语言）</p>
<p>这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序。</p>
<blockquote>
<p><strong>操作系统级</strong>（操作系统）：</p>
<p>从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸。</p>
<blockquote>
<p><code>软硬件分界</code>：</p>
<p><strong>传统机器级</strong>（机器语言）：</p>
<p>这级的机器语言是该机的指令集，程序员用机器指令编写的程序可以由微程序进行解释。</p>
<blockquote>
<p><code>硬件</code>：</p>
<p><strong>微程序级</strong>（微程序）：</p>
<p>这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的。</p>
<blockquote>
<p><strong>硬联逻辑级</strong>（硬联逻辑）：</p>
<p>这是计算机的内核，由门，触发器等逻辑电路组成。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p> </p>
<h2 id="构成">构成</h2>
<hr>
<blockquote>
<p>计算机的结构发展主要依赖于<strong>冯·诺依曼结构</strong>，以此为基础演变成了<strong>现代计算机</strong>的结构。</p>
<p>冯·诺依曼结构的要点：</p>
<ol>
<li>采用二进制。</li>
<li><strong>程序存储、顺序执行</strong>。</li>
<li>计算机由五个部分组成。</li>
</ol>
</blockquote>
<p> </p>
<h3 id="硬件">硬件</h3>
<hr>
<blockquote>
<ul>
<li><strong>冯·诺依曼结构</strong>，以<strong>运算器</strong>为中心。
<ol>
<li><strong>运算器</strong>： 是负责算术运算与逻辑运算，与控制器共同组成了中央处理器 （CPU）</li>
<li><strong>控制器</strong>： 负责发送和接收指令</li>
<li><strong>存储器</strong>： 用来存储程序和各种数据信息的记忆部件</li>
<li><strong>输入设备</strong>： 用来进行输入的设备。如鼠标、键盘...</li>
<li><strong>输出设备</strong>： 用来输出的设备。 如显示器、音箱...</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>现代计算机</strong>，以<strong>存储器</strong>为中心。
<ol>
<li><strong>CPU</strong>（Central Processing Unit，中央处理器）：
<ul>
<li>ALU（Arithmetic Logic Unit，算术逻辑单元）</li>
<li>CU（Control Unit，控制单元）</li>
</ul>
</li>
<li><strong>I/O设备</strong>（受CU控制）</li>
<li><strong>主存储器</strong>（Main Memory，MM)
<ul>
<li>RAM（随机存储器）：又称<strong>内存</strong>， 基于电存储，停电丢失，速度快 --- 随时读写，临时存储</li>
<li>ROM（只读存储器）：一经写入，无法修改，只能读取。如：BIOS芯片...</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<p> </p>
<h3 id="软件">软件</h3>
<hr>
<blockquote>
<p>软件本身是一堆数据，运行软件时，加载到内存，CPU到内存读取数据，通过运算再显示出来。</p>
</blockquote>
<blockquote>
<ul>
<li><strong>系统软件</strong>：基于硬件</li>
<li><strong>应用软件</strong>：基于系统软件</li>
</ul>
</blockquote>
<p> </p>
<h2 id="数据">数据</h2>
<hr>
<blockquote>
<p>计算机采用<strong>二进制</strong>的主要原因：</p>
<ul>
<li><strong>技术实现简单</strong>：计算机由逻辑电路组成，只有两个状态，开关的接通和断开，正好对应 1 和 0</li>
<li><strong>简化运算规则</strong></li>
<li><strong>适合逻辑运算</strong></li>
<li><strong>易于进行转换</strong>：二进制与十进制之间易于转换</li>
<li><strong>抗干扰能力强，可靠性高</strong>等</li>
</ul>
</blockquote>
<p> </p>
<h2 id="网络">网络</h2>
<hr>
<blockquote>
<p>每台计算机需要互相通讯需要用到网络协议，互联网本质是一系列网络协议</p>
<p><strong>局域网</strong>： 一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。<br>
<strong>城域网</strong>： 一种界于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网。<br>
<strong>广域网</strong>： 一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。 （ 如：Internet 因特网）</p>
</blockquote>
<p> </p>
<h3 id="osi-七层协议网络标准">OSI 七层协议（网络标准）</h3>
<hr>
<blockquote>
<p>互联网协议按照功能不同分为 OSI 七层 或 TCP/IP 五层 或 TCP/IP 四层 。主要讲解 TCP/IP 五层 。</p>
<p>对应如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>TCP/IP 四层</th>
<th>TCP/IP 五层</th>
<th>OSI 七层</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td></td>
<td></td>
<td>表示层</td>
</tr>
<tr>
<td></td>
<td></td>
<td>会话层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>网络接口层</td>
<td>数据链路层</td>
<td>数据链路层</td>
</tr>
<tr>
<td></td>
<td>物理层</td>
<td>物理层</td>
</tr>
</tbody>
</table>
<p> </p>
<h3 id="物理层">物理层</h3>
<hr>
<blockquote>
<p><strong>由来</strong>：<code>计算机之间需要用（光缆、电缆、双绞线、无线电波等连接，完成组网，才能通讯</code></p>
<p><strong>功能</strong>：<strong>主要是基于电器特性发送高低电压（电信号），高电压对应 1，低电压对应 0</strong></p>
</blockquote>
<p> </p>
<h3 id="数据链路层">数据链路层</h3>
<hr>
<blockquote>
<p><strong>由来</strong>：<code>单纯的电信号 0 和 1 没有任何意义，必须规定电信号多少位一组，每组什么意思</code></p>
<p><strong>功能</strong>：<strong>定义电信号的分组方式</strong></p>
</blockquote>
<p> </p>
<h5 id="以太网协议">以太网协议</h5>
<hr>
<blockquote>
<p>早期时各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议（ethernet）</p>
<p><strong>规定</strong>：</p>
<ul>
<li>一组点消耗构成一个数据包，叫做 <strong>帧</strong></li>
<li>每一数据帧分成：<strong>报头 head</strong> 和 <strong>数据 data</strong> 两部分</li>
</ul>
<p><strong>head</strong>：(固定18个字节)</p>
<ul>
<li>发送者/源地址：6个字节</li>
<li>接受者/目标地址：6个字节</li>
<li>数据类型：6个字节</li>
</ul>
<p><strong>data</strong>：（最短46个字节，最长1500字节）</p>
<ul>
<li>数据包的具体内容</li>
</ul>
<p><strong>发送</strong>：head 长度 + data 长度 = 最短 64字节 / 最长<strong>1518字节</strong>，超过最大限制就<strong>分片发送</strong></p>
<table>
<thead>
<tr>
<th>以太网头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p> </p>
<h5 id="mac-地址">MAC 地址</h5>
<hr>
<blockquote>
<p>head 中包含的源和目标地址由来：</p>
<p><code>ethernet 规定介入 Internet 的设备都必须具备网卡，发送端和接收端的地址便是 MAC 地址，以便能找到发送和接收者</code></p>
<p><strong>MAC</strong>： 每块网卡出厂时都有一个唯一的 mac地址，长度为 48 位 2进制，通常由 <strong>12 位 16 进制数</strong> 表示</p>
<p>（<code>前六位是厂商编号，后六位是流水线号</code>）</p>
</blockquote>
<p> </p>
<h5 id="广播">广播</h5>
<hr>
<blockquote>
<p>有了 mac 地址，同一网络内的两台主机就可以互相通讯了（一台主机通过 arp 协议获取另一台主机的mac地址），ethernet 采用最原始的方式，广播的方式进行通讯。</p>
</blockquote>
<p> </p>
<h3 id="网络层">网络层</h3>
<hr>
<blockquote>
<p><strong>由来</strong>：<code>有了</code>以太网协议<code>、</code>MAC 地址<code>、</code>广播<code>的发送方式，理论上世界上的计算机都可以互相通讯了。但是世界上的互联网是由一个个的局域网构成的，如果所有的通讯都是以以太网的广播方式传播，那么一台机器发送，全世界的机器都会收到，这将是一种灾难。于是就有了网络层，定义了一种协议 —— IP 协议。</code></p>
<p><strong>功能</strong>： <strong>引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址</strong></p>
</blockquote>
<p> </p>
<h5 id="ip-协议">IP 协议</h5>
<hr>
<blockquote>
<ul>
<li>规定网络地址的协议叫 ip 协议，定义的地址为 ip 地址， 广泛地采用 v4版本即 ipv4，它规定网络地址由 32 位 2进制表示</li>
<li>一个 ip 地址通常写成四段十进制数，范围 0.0.0.0 -- 255.255.255.255</li>
</ul>
<p><strong>IP地址分成两部分</strong>：</p>
<ul>
<li>网络部分：标识子网（前三段）</li>
<li>主机部分：标识主机（第四段）</li>
</ul>
<p><strong>子网掩码</strong>：区分两个IP地址是否在同一子网络。</p>
<p>方法为将两个IP地址进行<code>AND</code>运算（&amp;）， 然后比较结果是否相同，相同为同一子网，否则不是。</p>
<p><strong>IP数据包</strong>：</p>
<p><code>ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分</code></p>
<ul>
<li><strong>head</strong>：长度为 20 到 60 字节</li>
<li><strong>data</strong>：最长为 65,515 字节。</li>
</ul>
<p>而以太网数据包的<code>data</code>部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送。</p>
<table>
<thead>
<tr>
<th>以太网头</th>
<th>IP头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>总结</strong>：各个局域网间想要通讯需要用到<code>IP 协议</code>（ 即跨网络传输 ），首先将包发送给默认网关（相当于管理者），再由网关转发给 IP 地址所在局域网。</p>
<p> </p>
<h5 id="arp-协议">ARP 协议</h5>
<hr>
<blockquote>
<p>通信是基于 MAC 的广播方式实现，计算机在发包时，获取自身的 MAC 是容易的，如何获取目标主机的 MAC地址，就需要通过 <code>ARP 协议</code>。</p>
<p><strong>功能</strong>： 广播的方式发送数据包，获取目标主机的 <code>MAC 地址</code></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一子网</td>
<td>目标主机mac，目标主机 ip</td>
</tr>
<tr>
<td>不同子网</td>
<td>网关 mac，目标主机 ip</td>
</tr>
</tbody>
</table>
</blockquote>
<p> </p>
<h5 id="发送数据">发送数据</h5>
<hr>
<blockquote>
<p>设有主机<code>PC 1：192.168.11.10/24</code>、<code>PC 2：192.168.11.11/24</code>、<code>PC 3：172.16.45.10/24</code></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>源 MAC</th>
<th>目标 MAC</th>
<th>源 ip</th>
<th>目标 ip（不同子网为网关IP）</th>
<th>数据部分</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送端主机</td>
<td>发送端 MAC</td>
<td>FF:FF:FF:FF:FF:FF</td>
<td>172.16.10.10/24</td>
<td>192.168.11.11/24</td>
<td>数据</td>
</tr>
</tbody>
</table>
<p><strong>同一局域网内</strong>：<code>PC 1</code> ==&gt;<code>PC 2</code></p>
<ul>
<li>
<p>判断是否在同一局域网</p>
</li>
<li>
<p>利用<code>ARP 协议</code>获取<code>PC 2</code>的<code>MAC 地址</code></p>
<pre><code>PC1 MAC     FF:FF:FF:FF:FF:FF       192.168.11.10/24        192.168.11.11/24 
</code></pre>
</li>
<li>
<p>以上述格式发包，通过交换机广播，当所有PC拆包发现<code>IP</code>为自己时，回包加上自己的<code>MAC 地址</code></p>
<pre><code>PC2 MAC     PC1 MAC     192.168.11.11/24        192.168.11.10/24
</code></pre>
</li>
<li>
<p><code>PC 1</code>获得<code>PC 2</code>的<code>MAC 地址</code>后：</p>
<p>发包 <code>PC 1</code> ==&gt; <code>PC 2</code></p>
<pre><code>PC1 MAC     PC2 MAC     192.168.11.10/24    192.168.11.11/24    数据
</code></pre>
</li>
</ul>
<p><strong>不在同一局域网内</strong>：<code>PC 1</code> ==&gt;<code>PC 3</code></p>
<ul>
<li>
<p>判断是否在同一局域网</p>
</li>
<li>
<p>利用<code>ARP 协议</code>获取<code>网关1</code>的<code>MAC 地址</code>，再由<code>网关1</code>去联络<code>网关2</code>，最后获得<code>PC 3</code>的<code>MAC 地址</code></p>
<pre><code>PC1 MAC     FF:FF:FF:FF:FF:FF   192.168.11.10/24    192.168.11.1/24(网关) 
</code></pre>
</li>
<li>
<p>再将数据发给<code>网关1</code>，由<code>网关1</code>转发给<code>网关2</code></p>
<pre><code>PC1 MAC     网关1 MAC     192.168.11.10/24    172.16.45.10/24     数据
</code></pre>
</li>
<li>
<p><code>PC 3</code>==&gt;<code>PC 1</code>（回包），也是先判断是否处于同一局域网，在按照上述方式回包</p>
</li>
</ul>
<p><code>网关之间是通过路由传输</code></p>
<p> </p>
<h3 id="传输层">传输层</h3>
<hr>
<blockquote>
<p><strong>由来</strong>：<code>网络层的</code>IP<code>区分子网，以太网的</code>MAC<code>找到目标 主机，但是实际使用的是应用程序，那么要实现应用程序之间的通讯，是通过端口来标识应用程序的，即应用程序与网卡光联的编号。</code></p>
<p><strong>功能</strong>：<strong>建立端口到端口的通信</strong></p>
<p><strong>端口范围</strong>：0 - 65535	<code>0 -1023 为系统占用端口</code></p>
</blockquote>
<p> </p>
<h5 id="tcp-协议">TCP 协议</h5>
<hr>
<blockquote>
<p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
</blockquote>
<table>
<thead>
<tr>
<th>以太网头</th>
<th>IP头</th>
<th>TCP头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> </p>
<h5 id="udp-协议">UDP 协议</h5>
<hr>
<blockquote>
<p>不可靠传输，报头部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
</blockquote>
<table>
<thead>
<tr>
<th>以太网头</th>
<th>IP头</th>
<th>UDP头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> </p>
<h3 id="应用层">应用层</h3>
<hr>
<blockquote>
<p><strong>由来</strong>：<code>用户使用的应用程序，工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式</code></p>
<p><strong>功能</strong>： <strong>规定应用程序的数据格式</strong></p>
<p>例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了应用层。</p>
</blockquote>
<table>
<thead>
<tr>
<th>以太网头</th>
<th>IP头</th>
<th>TCP头 / UDP头</th>
<th>应用头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> </p>
<h3 id="socket">Socket</h3>
<hr>
<blockquote>
<p>两个进程需要进行通讯，最基本的一个前提是能够唯一的标识一个进程，在本地进程中我们可以使用 PID 来唯一标识一个进程，但 PID 只在本地唯一，网络中的两个进程 PID 冲突的几率很大。这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程 。</p>
<p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为<strong>套接字</strong>，socket是在<strong>应用层和传输层之间的一个抽象层</strong>，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<p>在 tcp、udp 协议之上，用户编写出一个应用软件时，需要定义其端口号，而单纯的使用 tcp、udp 协议去设定端口号费时费力，socket 大大节省了时间，只需简单的设置即可。</p>
</blockquote>
<p> </p>
<h3 id="传输过程">传输过程</h3>
<hr>
<blockquote>
<p>对于一个网络的传输过程来说，其实就是一个数据，在需要传输给网络中的另一个对象的时候，层层往下，不断往数据中添加内容（首部和尾部）。然后在物理网络中以比特传输，然后到达目标后，层层往上，不断剥离数据中的一部分（首部和尾部），最终又到达应用层，可以读出或者使用最终还原的数据。如下图所示：</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20180502201449179?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI3OTA4MjEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20180502201504631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI3OTA4MjEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></figure>
<p> </p>
<h2 id="运行">运行</h2>
<hr>
<blockquote>
<ul>
<li>计算机启动后，首先运行<code>BIOS</code>得知操作系统位置</li>
<li>启动操作系统（系统软件）：加载到内存，CPU从内存中读取再进行运算</li>
<li>打开应用软件：操作输入设备，发送指令给操作系统，将软件加载到内存中，然后CPU读取</li>
</ul>
<p><code>BIOS</code>：<code>属于物理层面，其代码已经写在主板上，属于ROM只读储存器</code></p>
<p><code>示例</code>：<code>打开编辑软件，它将运行于内存，只有保存后才会保存至硬盘，否则会丢失。</code></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6 - 初识]]></title>
        <id>https://AnCIity.github.io/post/es6-acquaintance/</id>
        <link href="https://AnCIity.github.io/post/es6-acquaintance/">
        </link>
        <updated>2019-11-01T08:52:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="变量">变量</h3>
<p><strong>let</strong>：块级作用域</p>
<p><strong>const</strong>：声明常量，必须赋一个初始值，不可改变，不可重复声明</p>
<h3 id="引入方式">引入方式</h3>
<blockquote>
<p>import require export</p>
</blockquote>
<h6 id="遵循规范">遵循规范</h6>
<ul>
<li><strong>require</strong> 是 AMD规范引入方式</li>
<li><strong>import</strong>是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li>
</ul>
<h6 id="调用时间">调用时间：</h6>
<p><strong>import</strong>：编译时调用，必须放在文件开头</p>
<p><strong>require</strong>：运行时调用，理论上可以运用在代码任何地方</p>
<h6 id="本质">本质：</h6>
<p><strong>import</strong>：解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p>
<p><strong>require</strong>：赋值过程，require的结果就是对象，数字，字符串，函数等，再把require的结果赋值给某个变量</p>
<p>export 与 import相对应 导出 导入</p>
<h3 id="箭头函数">箭头函数</h3>
<p>arrow function</p>
<pre><code class="language-js">function(i){ return i + 1; } //ES5
let funname = i =&gt; i + 1; //ES6一个参数一句代码简写
let funname = (a, b) =&gt; a + b;// 如果只有一句代码并为return，可省略return
let funname = (x, y) =&gt; {x++; y--; return x+y}; //ES6
</code></pre>
<h3 id="字符串嵌入">字符串嵌入</h3>
<p>template string</p>
<pre><code class="language-js">let name  = &quot;tony&quot;;
let str1 = &quot;hello,${name}!&quot;
let str2 = `hello,${name}!`
</code></pre>
<h3 id="构造函数">构造函数</h3>
<blockquote>
<p>constructor</p>
</blockquote>
<pre><code class="language-javascript">constructor(name,age){
            this.name = name;
            this.age = age;
        }
</code></pre>
<h3 id="对象">对象</h3>
<pre><code class="language-javascript">let foo =&quot;tony&quot;
    const obj = {
        foo: foo,// 同名可简写为：foo,
        bar:function () {// 可简写为：bar(){}
            console.log(this.foo)
        }
    }
    console.log(obj.bar())
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - 配置less环境]]></title>
        <id>https://AnCIity.github.io/post/vue-less-environment/</id>
        <link href="https://AnCIity.github.io/post/vue-less-environment/">
        </link>
        <updated>2019-11-01T07:58:00.000Z</updated>
        <content type="html"><![CDATA[<h5 id="安装less">安装Less</h5>
<pre><code class="language-shell">npm i less less-loader -S 
</code></pre>
<p>注意：独立的vue文件需要引入less</p>
<pre><code class="language-css">&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;
</code></pre>
<h5 id="配置全局变量">配置全局变量</h5>
<blockquote>
<p>Vue-cli3X<br>
vue.config.js</p>
</blockquote>
<pre><code class="language-js">const path = require('path');
module.exports = {
    pluginOptions: {
        'style-resources-loader': {
            preProcessor: 'less',
            patterns: [
                //这个是加上自己的路径，
                //注意：试过不能使用别名路径
                path.resolve(__dirname, 'src/assets/css/theme.less'),
            ]
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vuex - 概论]]></title>
        <id>https://AnCIity.github.io/post/vue-vuex-generality/</id>
        <link href="https://AnCIity.github.io/post/vue-vuex-generality/">
        </link>
        <updated>2019-11-01T07:55:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vuex-概论">Vuex - 概论</h2>
<h3 id="核心概念">核心概念</h3>
<hr>
<h4 id="state"><strong>State</strong></h4>
<blockquote>
<p>数据仓库</p>
</blockquote>
<h4 id="getter"><strong>Getter</strong></h4>
<blockquote>
<p>获取仓库数据</p>
</blockquote>
<h4 id="mutation"><strong>Mutation</strong></h4>
<blockquote>
<p>定义变化</p>
</blockquote>
<ul>
<li>定义变化，处理状态（数据）的改变</li>
</ul>
<h4 id="action"><strong>Action</strong></h4>
<blockquote>
<p>使用 <strong>commit</strong> 提交 Mutation 定义的变化</p>
<p><strong>commit</strong> ：</p>
<blockquote>
<p>提交变化，修改数据的唯一方式就是显示的提交 mutations</p>
</blockquote>
</blockquote>
<ul>
<li>定义方法（动作）,可以使异步的发送请求。</li>
</ul>
<h4 id="module"><strong>Module</strong></h4>
<blockquote>
<p>模块化</p>
</blockquote>
<h3 id="工作流程">工作流程</h3>
<hr>
<figure data-type="image" tabindex="1"><img src="https://AnCIity.github.io/post-images/1572597146141.png" alt="" loading="lazy"></figure>
<ol>
<li>在vue组件里面，通过<strong>dispatch</strong>来触发<strong>actions</strong>提交修改数据的操作。</li>
<li>然后再通过<strong>actions</strong>的<strong>commit</strong>来触发<strong>mutations</strong>来修改数据。</li>
<li><strong>mutations</strong>接收到<strong>commit</strong>的请求，就会自动通过<strong>Mutate</strong>来修改<strong>state</strong>（数据中心里面的数据状态）里面的数据。</li>
<li>最后由<strong>store</strong>触发每一个调用它的组件的更新。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - 配置跨域请求]]></title>
        <id>https://AnCIity.github.io/post/vue-pei-zhi-kua-yu-qing-qiu/</id>
        <link href="https://AnCIity.github.io/post/vue-pei-zhi-kua-yu-qing-qiu/">
        </link>
        <updated>2019-11-01T06:19:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="vue-配置跨域请求">Vue - 配置跨域请求</h3>
<blockquote>
<p>示例API：http://127.0.0.1:5000/api/menu</p>
</blockquote>
<h5 id="配置">配置</h5>
<blockquote>
<p>package.json同级目录下vue.config.js新建</p>
</blockquote>
<pre><code class="language-js">//axios域代理，解决axios跨域问题
devServer: {
    proxy: {
        '': {
            target: 'http://127.0.0.1:5000',
            changeOrigin: true,
            ws: true,
            pathRewrite: {}
        }
    }
}
</code></pre>
<h5 id="调用">调用</h5>
<pre><code class="language-js">this.$http
.get('/api/menu')
.then(response =&gt; (this.Fi_sorts = response.data.Fi_sorts))
.catch(function (error) { // 请求失败处理
	console.log(error);
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - 实例常用属性]]></title>
        <id>https://AnCIity.github.io/post/vue-attr/</id>
        <link href="https://AnCIity.github.io/post/vue-attr/">
        </link>
        <updated>2019-11-01T06:16:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-实例常用属性">Vue - 实例常用属性</h2>
<h3 id="数据">数据</h3>
<hr>
<p><strong>data</strong></p>
<blockquote>
<p>数据对象</p>
</blockquote>
<ul>
<li>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</li>
</ul>
<p><strong>components</strong></p>
<blockquote>
<p>注册组件</p>
</blockquote>
<h3 id="组件">组件</h3>
<hr>
<p><strong>props</strong></p>
<blockquote>
<p>数据传递</p>
</blockquote>
<ul>
<li>用于接收来自父组件的数据</li>
</ul>
<p><strong>template</strong></p>
<blockquote>
<p>组件模板</p>
</blockquote>
<ul>
<li>用来设置模板，会替换页面元素，包括占位符。</li>
</ul>
<h3 id="类方法">类方法</h3>
<hr>
<p><strong>methods</strong></p>
<blockquote>
<p>实例方法</p>
</blockquote>
<ul>
<li>放置页面中的业务逻辑，js方法一般都放置在methods中</li>
<li>methods方式在使用时要像方法一样去用，必须加()</li>
<li>methods方式是每次进入页面都要执行该方法，但是在利用实时信息时，比如显示当前进入页面的时间，必须用methods方式</li>
</ul>
<p><strong>computed</strong></p>
<blockquote>
<p>计算属性</p>
</blockquote>
<ul>
<li>用来计算</li>
<li>computed计算属性的方式在用属性时不用加()</li>
<li>computed计算属性是将方法与数据绑定，只有当数据发生变化时才会触发方法</li>
</ul>
<p><strong>watch</strong></p>
<blockquote>
<p>侦听属性</p>
</blockquote>
<ul>
<li>watch:function(new,old){}</li>
<li>监听data中数据的变化</li>
<li>两个参数，一个返回新值，一个返回旧值，</li>
</ul>
<p><strong>filters</strong></p>
<blockquote>
<p>过滤器</p>
</blockquote>
<p><strong>render</strong></p>
<blockquote>
<p>渲染函数，创建虚拟DOM</p>
</blockquote>
<h3 id="生命周期">生命周期</h3>
<hr>
<p><strong>created</strong></p>
<blockquote>
<p>初始化</p>
</blockquote>
<ul>
<li>在实例创建完成后被立即调用，完成初始化操作</li>
</ul>
<p><strong>mounted</strong></p>
<blockquote>
<p>挂载后</p>
</blockquote>
<ul>
<li>el挂载到Vue实例上了，开始业务逻辑操作</li>
</ul>
<p><strong>beforeDestroy</strong></p>
<blockquote>
<p>销毁前</p>
</blockquote>
<ul>
<li>实例销毁之前调用</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 推送已有项目到远程仓库]]></title>
        <id>https://AnCIity.github.io/post/git-tui-song-yi-you-xiang-mu-dao-yuan-cheng-cang-ku/</id>
        <link href="https://AnCIity.github.io/post/git-tui-song-yi-you-xiang-mu-dao-yuan-cheng-cang-ku/">
        </link>
        <updated>2019-10-31T07:20:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="git-推送已有项目到远程仓库">Git - 推送已有项目到远程仓库</h2>
<blockquote>
<p>提示：</p>
<p>在GitHub中新建好仓库</p>
</blockquote>
<blockquote>
<p>配置用户信息（已配置过，则忽略）</p>
</blockquote>
<pre><code class="language-shell">git config --global user.name 'AnCIity'
git config --global user.email 'city@nanzc.com'
</code></pre>
<blockquote>
<p>初始化git</p>
</blockquote>
<pre><code class="language-shell">git init
</code></pre>
<blockquote>
<p>关联网络仓库</p>
</blockquote>
<pre><code class="language-shell">git remote add origin &lt;新建的仓库地址&gt;
</code></pre>
<blockquote>
<p>添加到暂存区</p>
</blockquote>
<pre><code class="language-shell">git add .
</code></pre>
<blockquote>
<p>把文件提交到仓库，引号内为提交说明</p>
</blockquote>
<pre><code class="language-shell">git commit -m ''
</code></pre>
<blockquote>
<p>获取远程库与本地同步合并</p>
</blockquote>
<pre><code class="language-shell">git pull --rebase origin master
</code></pre>
<blockquote>
<p>推送到远程仓库</p>
</blockquote>
<pre><code class="language-shell">git push -u origin master
</code></pre>
]]></content>
    </entry>
</feed>